{"pages":[],"posts":[{"title":"Tóm tắt 2 năm sử dụng NodeJS","text":"Giai đoạn 1 : Tiếp cận.Mình bắt đầu sử dụng NodeJS vào học kỳ 1 năm 5 đại học. Nền tảng lập trình Web của mình trước khi tiếp cận NodeJS : Về thực hành, thực tập với ASP.NET 1 tháng rưỡi vào cuối năm 3. 2 project PHP ở trường đại học. Về lý thuyết, mình nắm (sơ sơ) các khái niêm cơ bản : client, server, giao thức http. Biết code HTML, CSS và JavaScript. Khi tiếp xúc với NodeJS, cảm nhận đầu tiên của mình là nó dễ tiếp cận hơn ASP.NET, thực tập năm 3 có được sử dụng ASP.NET và thấy nó hơi khó tiếp cận (trình độ lúc đó kém) ngoài ra Visual Studio khá nặng và phần cấu hình chỉnh chỉnh cái file xml thì hoàn toàn không hiểu gì. Một điểm nữa là để thực thi chương trình (webserver) chỉ cần gõ 1 lệnh “node app.js” là nó tự chạy, không cần phải cài đặt server, phần này làm mình khá thích vì mỗi lần đụng đến cấu hình hay cài đặt một cái gì đó thì mình khá e ngại. Dần dần mình nhận ra những điểm lợi khác của NodeJS Dùng code JS cả frontend và backend =&gt; không cần phải học thêm một ngôn ngữ phía server. Để viết 1 app đơn giản thì rất nhanh, không cần phải thiết kế class với các nguyên tắc của lập trình hướng đối tượng. Ngoài việc code logic của ứng dụng, những phần còn lại thì hầu hết đều có một module trên npm có thể cài đặt và sử dụng rất dễ dàng, từ quản lý session, cho phép request cross domain,… và nhiều chức năng khác. Mình cảm thấy rất tiện. (Phần này mình không có ý dìm hàng các công nghệ khác, quan điểm cá nhân là với một người không có nhiều kinh nghiệm về web thì NodeJS khá là dễ tiếp cận) Giai đoạn 2 : Gặp rắc rối.Sau khi học NodeJS được 1 học kỳ, bắt đầu đi thực tập và sử dụng NodeJS. Ở giai đoạn này, mình vẫn dùng style code được học trên trường để viết code. Công ty mình thực tập là 1 startup, mình được giao công việc và hướng dẫn khi gặp khó khăn, mục tiêu là hoàn thành sản phẩm nhanh chóng nên không có nhiều code review. Mình code khá tự do. Bây giờ nhìn lại thì thấy thiếu sót của mình ở giai đoạn này là không lên mạng tìm hiểu xem người ta đang sử dụng NodeJS như thế nào. Theo thời gian, những chức năng được thêm vào, project ngày càng lớn dần lên. Mối liên hệ giữa các thành phần trong project ngày càng trở nên rối rắm hơn.Mình cảm thấy project của mình không có một chuẩn, qui tắc nào, và bắt đầu trở nên khó quản lý theo thời gian. Ở mức thấp hơn, code nhìn xấu với nhiều hàm callback lồng nhau. Mình bắt đầu tìm hiểu trên mạng những “best practices” cho NodeJS (và cả những vấn đề khác liên quan tới việc viết API). Mình tìm thấy trang https://github.com/goldbergyoni/nodebestpractices tập hợp rất nhiều những « best practices » hữu ích khi làm việc với NodeJS. Từ cấu trúc project, xử lý lỗi, cách viết code,… tất cả đều được tập hợp trong một link duy nhất, một link duy nhất 😊. Khi xem các bài viết trong trang này, mình thấy code của mình đụng đến khá nhiều những điểm sai sót, những điểm lớn mà mình nhớ là : Cấu trúc project theo lớp : mình chia file theo lớp, lớp route, lớp logic và lớp access database. Thật ra lúc ban đầu mình không hề nhận ra điều này, chỉ sau khi project lớn dần lên và mình liên tục phải kéo chuột lên xuống để tìm file thì thấy rất bất tiện Callback hell : ban đầu mình sử dụng callback, đây là cách mình được học trong trường. Lúc đó mình dùng callback thì cũng không cảm thấy có vấn đề gì. Cho đến khi project của mình ngày càng có nhiều business phức tạp thì một hàm của mình chứa rất nhiều callback, mà mỗi lần callback thì code nó bị thụt vào trong nên rất khó coi. Đỉnh điểm mình nhớ có một hàm nó tụt vào gần giữa trang code Nếu bạn đang sử dụng NodeJS và làm 2 điều này thì nên thay đổi ngay, đừng như mình 😊 Và còn nhiều điểm khác, ngoài ra project mình còn có những lỗi sau, liên quan tới việc viết API : Về việc sử dụng phương thức httpThời gian đó project của mình chỉ có 2 method : get và post. Get để lấy thông tin từ server, Post để server làm gì đó với thông tin được post. Mình lên mạng tìm hiểu các phương thức của http, ngoài get và post còn có put, delete, head, option… Sau đó mình nghiên cứu và sử dụng thêm put và delete. Về việc đặt tên cho APIThời gian đầu đi làm mình hay đặt tên api dạng /createuser, /modifyuser, /deleteuserSau khi tìm đọc về cách đặt tên API, mình rút ra một bài học là không nên để các động từ như create/modify/delete/get vào trong api, tên phương thức http sẽ thể hiện thông tin đó. Ví dụ : 12345Get /users/id : get user bằng idGet /users?query: get nhiều users, có thể sử dụng queryPost /users : tạo một userPut /user : update thông tin một userDelete /user : xóa user Theo cách này tên của các api sẽ đơn giản và nhất quán hơn. Giai đoạn 3 : Cập nhật kiến thức mớiLại nói về project NodeJS của mình, tại thời điểm đọc được những best practices thì project này cũng đã tương đối to để mình có thể refactor nên mình không refactor code cũ. Tuy nhiên mình sẽ viết những code mới theo các best practices đã đọc. Tương ứng với 2 (trong số rất nhiều) lỗi mà mình đã phạm ở giai đoạn 2, mình áp dụng kiến thức mới. Cấu trúc project : với một tính năng mới được thêm vào project, mình sẽ tạo một thư mục mới chứa toàn bộ file liên quan đến tính năng đó ở các tầng khác nhau. Ví dụ, khi thêm tính năng quản lý người dùng thì mình sẽ tạo một thư mục user chứa các file : user.service, user.data, user.test, user.route. Coding style : mình sử dụng async/await. 2 từ khóa này giúp việc viết code bất đồng bộ trở nên dễ dàng hơn nhiều. Code bất đồng bộ sử dụng 2 từ khóa này trông giống y như một đoạn code đồng bộ thông thường. Tới thời điểm này, sau 2 năm sử dụng NodeJS, mình thực hiện một project nho nhỏ để cài đặt tất cả những best practices mà mình thấy hữu dụng nhất và sử dụng nó như một template cho các project NodeJS sau này của mình. Những best practices đó là : Chia project theo chức năng (như mình đã nói ở trên). Ngăn cách rõ các tầng trong project.Ví dụ, nếu ở tầng route mình truyền thẳng 2 biến req và res vào tầng business thì mình đã tạo ra sự phụ thuộc của tầng business vào tầng route. Điều này làm cho việc test code business trở nên khó khăn. Thay vào đó, tại tầng route, mình chỉ lựa những trường nào cần thiết để truyền vào, thương là các trường trong req.body hoặc là req.params.Một điểm mà mình hay thấy ở các project NodeJS trên Github là, tại tầng model, họ sẽ export ra model để tầng Business sử dụng. Tầng business có thể sử dụng các method find, findOne, findOneAndUpdate được xây dựng sẵn trong thư viện Mongoose. Suy nghĩ của mình có hơi khác, mình sẽ viết các hàm truy xuất dữ liệu tại tầng model. Mình thấy có 2 điểm lợi chính để mình giữ cách viết này mặc dù nhìn khá thừa thãi và tốn công code. Thứ nhất, nếu api của Mongoose có sự thay đổi thì mình chỉ thay đổi trong tầng model Thứ hai, mình giới hạn được những method mà tầng Business có thể sử dụng Sử dụng thư viện logger thay cho console.logConsole.log rất quan trọng vì nó cung cấp thông tin của chương trình. Console.log những điểm quan trọng trong chương trình với một style rõ ràng giúp ích rất nhiều trong quá trình debug cũng như phát hiện điều bất thường khi server hoạt động. Viết unit testTheo sách clean code, test enables all the -ilities. Vì nó cho phép chúng ta thay đổi, chỉnh sửa code. Một ngày nào đó bạn thấy coding style rất là xấu và bạn muốn refactor, hoặc một tính năng nào đó trong chương trình cần phải cập nhật theo yêu cầu mới. Nếu bạn có sẵn các test thì việc thay đổi code sẽ không làm bạn lo lắng xem nó có ảnh hưởng tới những phần khác của chương trình hay không. Chỉ cần vượt qua các test là xong 😊. Cấu trúc apiNếu mình sử dụng các api viết trong file user.route với prefix /users thì trong file này thay vì phải viết /users/id mình chỉ cần viết /id. Điều này cho phép mình có một cấu trúc api nhiều tầng (nhiều /) và tránh sự lặp lại không cần thiết. Chiêm nghiệmLý do mình viết bài này là vì một câu nói của chú Nguyễn Hữu Thái Hòa trong một video mình coi trên youtube. “Học thì học rất nhiều nhưng mà ngộ (wisdom) ra được cái gì mới là quan trọng”. Mình viết bài này để đóng gói lại 2 năm sử dụng NodeJS, từ giai đoạn tiếp cận, tới những rắc rối cho đến việc cập nhật kiến thức mới để sử dụng công nghệ này “chuẩn” hơn. Cần phải nói một điều, giai đoạn 2 và 3 ở bên trên diễn ra tuần hoàn chớ không tuần tự. Khi mình suy nghĩ tới những công nghệ khác mình sử dụng khi đi làm : AngularJS và MongoDB, bỗng nhiên mình thấy có những điểm hoàn toàn tương tự với NodeJS. Mình cũng bắt đầu tiếp cận các công nghệ này với sự hứng khởi vì chúng có những điểm tốt hơn so với những thứ mình đã sử dụng trước đó (JS thuần với AngularJS, MySQL với MongoDB) sau đó gặp rắc rối trong quá trình sử dụng và rồi lại cập nhật kiến thức mới để giải quyết những rắc rối gặp phải. Mình rút ra một kết luận mà ai cũng biết đó là việc học hỏi, cập nhật cái mới cần diễn ra một cách liên tục. Nhưng giờ, với những gì mình đã trải qua, mình đã hiểu sâu sắc lý do của việc đó. Nếu chúng ta không cập nhật cái mới thì sớm muộn chúng ta sẽ “gặp rắc rối”.Thế cái này mà đem vào chuyện hôn nhân gia đình thì sao nhỉ ? :D. Các bạn tự có câu trả lời hợp lý nhé :v.","link":"/2019/11/03/2namnodejs/"},{"title":"SSH - Kiến thức căn bản và ứng dụng","text":"Mục đích bài viếtTrong quá trình đi làm của mình, ngoài việc viết code, một hoạt động khác chiếm khá nhiều thời gian là việc đẩy code lên remote repository, hay deploy code lên server. Khi làm việc với git hay server, chúng ta không thể không nhắc tới thuật ngữ SSH. Bài viết này của mình nhằm mục đích hệ thống lại các kiến thức liên quan đến SSH, từ phần kiến thức nền tảng, tới các việc sử dụng SSH trong thực tế. Giới thiệu SSHKhi làm việc với server, ta cần một phương thức cho phép ta kết nối với server từ máy tính của mình. SSH là một trong những phương thức đó. SSH là phương thức giúp chúng ta thiết lập một kết nối bảo mật tới server từ xa. Kết nối này cho phép bạn làm việc trực tiếp với shell của server. Từ đó bạn có thể làm việc với server giống như đang làm với máy của mình. Vậy là xong phần định nghĩa. Bây giờ mình xin phép điểm lại một số kiến thức cơ bản trước khi bắt đầu thực hành sử dụng công cụ này. Phần này sẽ giúp chúng ta hiểu rõ ý nghĩa của một file config hay một thông báo lỗi… từ đó biết/hiểu mình cần phải làm gì ngay cả khi copy code trên mạng. Kiến thức nền : Mã hóaỞ phần trên, chúng ta đã nhắc đến bảo mật. SSH cho phép ta thiết lập một kết nối bảo mật. Để thực hiện điều đó, SSH sử dụng các thuật toán mã hóa khác nhau. Trong phần này mình xin nhắc lại các khái niệm mã hóa, mã hóa đối xứng, mã hóa phi đối xứng. Mã hóa Mã hóa là việc diễn đạt một thông tin theo dạng không thể hiểu được trừ khi bạn có phương tiện để giải mã. Mã hóa đảm bảo sự an toàn, bảo mật cho việc trao đổi thông tin giữa 2 bên. Các thuật toán mã hóa có thể được chia ra thành 2 lớp : mã hóa đối xứng và mã hóa phi đối xứng. Mã hóa đối xứngMã hóa đối xứng là một lớp các thuật toán mã hóa mà trong đó việc mã hóa và giải mã thông tin chung một khóa (giải mã là quá trình ngược lại của mã hóa). Khóa này cần được bảo vệ. Mã hóa đối xứng giúp cho thông tin được trao đổi được giữ bí mật. Chỉ những người có khóa mới có thể giải mã thông tin. Mã hóa phi đối xứngTrái ngược với mã hóa đối xứng, các thuật toán mã hóa phi đối xứng sử dụng 2 khóa khác nhau để mã hóa và giải mã thông tin. Mỗi người cần có một cặp khóa. Trong đó, khóa công khai có thể công khai cho mọi người, còn khóa bí mật thì của riêng mỗi người và không được chia sẻ cho bất cứ ai. Khi thông tin được mã hóa bằng một khóa nào đó trong cặp khóa thì chỉ có duy nhất khóa còn lại trong cùng một cặp mới có thể giải mã. Mã hóa phi đối xứng cũng cung cấp cho chúng ta khả năng bảo mật thông tin giống như mã hóa đối xứng. Nếu bên A mã hóa tin nhắn bằng khóa công khai của bên B thì chỉ có duy nhất bên B với khóa bí mật của mình mới có thể giải mã. Ngoài ra, nó còn 2 khả năng sau mà mã hóa đối xứng không có : Giúp ta xác nhận ai là người gởi thông tin. (*) Người đã gởi thông tin không thể chối bỏ hành động của mình Đây là trường hợp khi bên A mã hóa tin nhắn bằng khóa bí mật của chính mình. Bên B dùng khóa công khai của bên A để giải mã. Nếu giải mã thành công chứng tỏ tin nhắn chỉ có thể được gởi đi từ bên A. Đồng thời, bên A cũng không thể chối bỏ rằng mình đã gởi tin nhắn này vì nếu là một ai khác gởi thì bên B không thể dùng khóa công khai của bên A để giải mã. Tính chất (*) là một cơ sở quan trọng cho SSH, vì nó giúp server xác thực ai là người đang kết nối với hệ thống. Điều này cho phép server có thể chấp nhận hoặc từ chối kết nối. Quá trình xác thực sử dụng SSH không yêu cầu mật khẩu, thay vào đó khóa bí mật sẽ được sử dụng cùng với các khóa công khai được cho phép (authorized_keys) trên server. So sánh 2 phương pháp xác thực bằng mật khẩu và bằng khóa bí mật, ta thấy rằng : Xác thực bằng khóa bí mật cho phép ta tự động hóa các câu lệnh vì server shell không yêu cầu nhập mật khẩu. Xác thực bằng khóa bí mật cho ta biết ai là người truy cập hệ thống. Với mật khẩu, người đăng nhập vào hệ thống chỉ là một người nào đó biết mật khẩu. Với việc không sử dụng mật khẩu, xác thực bằng khóa bí mật an toàn hơn. Mỗi người trong một nhóm có thể dùng khóa bí mật của riêng mình để đăng nhập vào hệ thống chung thay vì chia sẻ với nhau một mật khẩu. Đó cũng chính là những điểm mạnh của SSH. Bây giờ, chúng ta sẽ nói về việc sử dụng SSH trong thực tế. Sử dụng SSH khi đi làmSử dụng SSH với Git hosting serviceKhi làm việc với git hosting service như GitHub, chúng ta có thể clone, push, pull.. một repository sử dụng giao thức HTTPS hoặc SSH. Nếu sử dụng HTTPS, mỗi khi push, pull .. chúng ta cần phải nhập tài khoản và mật khẩu GitHub. Nếu sử dụng SSH, chúng ta cần phải cung cấp cho GitHub khóa công khai của mình (trong mục Settings &gt; SSH and GPG keys). Sau đó, mỗi khi push, pull… thay vì phải nhập tài khoản và mật khẩu GitHub, chúng ta chỉ cần nhập mật khẩu của khóa bí mật (passphrase), hoặc không cần phải gõ thêm gì nếu bạn không setup passphrase khi tạo khóa. GitHub sử dụng khóa công khai để xác thực xem ta là ai và có quyền đọc/ghi repository hay không và chấp nhận hoặc từ chối câu lệnh của chúng ta. Rõ ràng cách 2 tiện hơn vì chúng ta đỡ phải nhập dữ liệu. Trong trường hợp không có passphrase, quá trình push/pull repository có thể được hoàn thành bằng việc chạy script. Điều này cho phép ta tự động hóa việc deploy code lên server. Cấu hình SSHĐể cấu hình SSH, chúng ta sẽ làm việc với thư mục .ssh. Đây là thư mục chứa các file quan trọng để sử dụng giao thức SSH : authorized_keys, known_hosts và config. Dưới đây mình xin giải thích ý nghĩa của từng file : authorized_keys : trong file này chứa danh sách các khóa công khai của những người có thể truy cập vào hệ thống.Khi một người kết nối tới server, tin nhắn được mã hóa bởi khóa bí mật của họ sẽ được giải mã bởi lần lượt các khóa công khai trong authorized_keys. Nếu một trong số các khóa công khai này có thể giải mã thành công thì người đó sẽ được cho phép kết nối vào server. Vậy, nếu bạn muốn truy cập vào user user của server server sử dụng giao thức SSH, bạn chỉ cần thêm khóa công khai của mình vào file authorized_keys trong thư mục .ssh của user user. Điều này về mặt bản chất cũng giống như khi bạn thêm khóa công khai vào tài khoản GitHub của mình. known_hosts : trong file này chứa danh sách các host bạn đã truy cập. Các thông tin trong file giúp máy tính kiểm tra danh tính host mà nó đang kết nối để chắc chắn rằng nó đang kết nối tới đúng nơi, tránh việc bị kẻ xấu redirect kết nối vào máy của họ. config : file này chứa các thiết lập SSH. Khi chúng ta sử dụng một kết nối SSH thường xuyên, chúng ta có thể lưu các tham số của kết nối đó vào file này. Câu lệnh SSH sẽ được rút ngắn hơn.Ví dụ, khi bạn lưu đoạn text dưới đây vào file ~/.ssh/config 1234Host alias HostName hostname User username IdentityFile ~/.ssh/private_key Thì câu lệnh ssh alias sẽ tương đương với ssh username@hostname -i ~/.ssh/private_key Mình sử dụng file config này khi cần phải thiết lập một tài khoản GitLab thứ 2. Các bạn có thể xem chi tiết tại đây. Một ví dụ về việc vận dụng lý thuyết để giải quyết lỗiTrong phần này, mình xin giới thiệu một lỗi hay gặp khi làm việc với SSH và cách giải quyết. Bạn sẽ thấy phần kiến thức cơ bản có ích cho chúng ta như thế nào. Bạn có thấy cái thông báo này quen quen không ? Đây là lỗi hay gặp khi chúng ta copy khóa bí mật từ máy này sang máy khác sau đó sử dụng SSH ngay. Như trong phần lý thuyết mình đã đề cập, khóa bí mật là của riêng mỗi người và không được chia sẻ cho bất kỳ ai. Trong hình, khóa có permission là 644, có nghĩa là mọi người có thể đọc được nội dung của khóa, vi phạm nguyên tắc của khóa bí mật dẫn đến lỗi. Vấn đề đã rõ, ta cần giới hạn permission của khóa. Ta có thể cân nhắc giữa 400 hoặc 600. Xong ! Tổng kếtSSH là một công cụ mà mình sử dụng khá thường xuyên trong công việc. Lúc ban đầu mình cũng lên mạng copy những đoạn lệnh về dán vào terminal để chạy nhưng mình không nắm rõ bản chất. Khi phải cấu hình những trường hợp phức tạp hơn hay gần đây làm việc với GitLab CI/CD thì mình rất lúng túng. Sau khi hệ thống lại, mình dễ dàng nhìn ra mối liên hệ chặt chẽ giữa kiến thức cơ bản và ứng dụng trong thực tế. Hiểu rõ được điều này giúp mình tự tin hơn khi làm việc. Hi vọng bài viết này có ích với bạn đọc. Hẹn gặp lại !","link":"/2019/12/21/SSHKienthuccobanvaungdung/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"CI/CD","slug":"CI-CD","link":"/tags/CI-CD/"}],"categories":[{"name":"IT","slug":"IT","link":"/categories/IT/"},{"name":"Backend","slug":"IT/Backend","link":"/categories/IT/Backend/"},{"name":"DevOps","slug":"IT/DevOps","link":"/categories/IT/DevOps/"}]}